## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2402`

#### Выполнила: `Белова Полина Сергеевна`

#### Вариант: `3`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Программа получает на вход 2 целых числа N и M. Затем считывает ещё N x M элементов (целых чисел). Далее программа выполняет еще несколько действий, таких как: сортирование элементов массива по столбцам по возрастанию методом пузырька, сортирование элементов массива по строчкам по убыванию методом вставок, сортирование элементов главной диагонали массива по возрастанию, вычисление количества нечётных элементов и их среднего арифмитического, вывод массива в зигзагообразном порядке, замена всех чётных чисел на их отрицательные значения и нечётных чисел на их квадраты и вывод массива.

#### Разобью для удобства свою работу на несколько подзадач:
> 
- №1. Создать массив, а также заполнить его числами. В этот шаг я еще для удобства и экономии времени добавлю вычисление количества нечётных чисел и найду их среднее арифмитическое.
- №2. Отсортировать каждый столбец в порядке убывания методом пузырьков.
- №3. Отсортировать каждую строчку в порядке возрастания методом вставок.
- №4. Вывести массив в зигзагообразном порядке с помощью 1 цикла (по условию).
- №5. Заменить все чётные числа на их отрицательные значения и все нечётнае числа на их квадраты.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать 2 числа (N и M), которые задают массив, и далее некоторое количество чисел, которыми мы этот массив заполняем. В условии сказано, что числа принадлежат множеству целых. Также следует отметить, что N и M не могут принимать неположительные значения, так как они задают массив. Так как по условию диапазон задан не был, установлю его сама. Поэтому min = 1, a max = половине вместимости ячейки типа int. 
Количество элементов массива зависит от заданного размера и вычисляется по формуле N x M.
a[i][j] - i-тый (по строчкам) j-тый (по столбцам) элемент массива. 

|             | Тип                       | min значение    | max значение   |
|-------------|---------------------------|-----------------|----------------|
| N (Число 1) | Целое положительное число | 1               | 2<sup>31</sup> |
| M (Число 2) | Целое положительное число | 1               | 2<sup>31</sup> |
| a[i][j]     | Целое число               | -2<sup>31</sup> | 2<sup>31</sup> |


#### Данные на выход

На выход мы получаем всё те же элементы массива (N x M элементов), которые могут принимать как отрицательное значение, как положительное, так и 0.

|         | Тип                                | min значением | max значение   |
|---------|------------------------------------|---------------|----------------|
| a[i][j] | Целое число                        |-2<sup>31</sup>| 2<sup>31</sup> |

### 3. Выбор структуры данных

Программа получает 2 целых числа, не превышающих 2<sup>31</sup>. Поэтому для их хранения
можно выделить 2 переменных (`n` и `m`) типа `int`. 

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| N (Число 1) | `n`                 | `int`        |
| M (Число 2) | `m`                 | `int`        | 

Для вывода результата необязательно его хранить в отдельной переменной.

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает два целых числа, обозначенные как `n` и `m`.

2. **Описание массива, инициализация некоторых переменных:**  
   Описываем двумерный массив a, инициализируем переменные с (int, так как количество - натуральное число) и sum (double, для удобства вычислений, т.к. среднее арифметическое необязательно будет целым числом), которым изначально присваиваем значение 0.

3. **Заполнение массива и поиск среднего арифмитического:**
   Заполняем массив элементами, на каждой итерации проверяя введеный элемент на чётность, если число нечётное - увеличиваем счётчик на 1, а сумму на само число. Если число нечётное - ничего не происходит. Как результат: заполненный двумерный массив и переменная ave (double, т.к. sum - double), к которой сможем обратиться в любое время (нас не просили выводить). Также можем не создавать переменную и просто вывести ответ через - out.printf("%.x", sum/c), с возможностью указать точность.

4. **Сортировка по столбцам:**  
   Сортируем массив по столбцам по возрастанию, используя метод пузырьков. Метод пузырьков заключается в сравнении пар чисел, которые обмениваются значениями при каком-либо условии. Начну действовать со 1-ого (0-ого) столбца, продвигаясь в обратном направлении с его последнего элемента (a[i][0]). Сравню его с предыдущим. Если a[i][0] < a[i-1][0] (предудщий элемент), то с помощью перетекания мы сначала запомним предыдущий элемент в локальную переменную `x`, а затем поменяем их местами. И так далее по всей строчке (цикл с k помогает выполнить необходимое количество сравнений (на 1 меньше чем всего элементов)), а затем для каждого столбца.
   
5. **Сортировка по строчкам:**
   Сортируем массив по строчкам по убыванию, используя метод вставок. Метод вставок заключается в том, что мы принимаем первый элемент строчки за уже отсортированную последовательность. Далее берем 2-ой (1-ый по индексу) элемент, называея его текущим и далее в цикле сравниваем его с предыдущими элементами, переставляя его в зависимости от условия. Двигаемся мы каждый раз с конца в начало. Каждый следующий элемент a[i][j] проходит один и тот же путь, занимая свое место, выполнив цикл некое количество раз.

6. **Сортировка главной диагонали:**
   Сортируем главную диагональ по возрастанию, используя метод пузырьков. Продвигаемся от левого верхнего элемента по диагонали вниз, сравнивая попарно элементы, лежащие на этой диагонали.

7. **Вывод массива:**
   Вывод зигзагом, начиная с левого верхнего элемента, используя 1 цикл. Мы проходим целиком проходим строчку, спускаемся вниз на следующую и движемся в обратном направлении. Так делааем до тех пор, пока все элементы не будут выведены.

8. **Замена и вывод:**
   Всё достаточно просто - проверяем каждый элемент массива на чётность. Если элемент кратен 2, то мы меняем его на то же значение, только со знаком минус. Если число при делении на 2 даёт остаток 1, то мы меняем его на возведённое в квадрат число. И с помощью 2 вложенных циклов выводим итоговый массив!
   

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Arrays;
import java.util.Scanner;
public class Main {
    public static PrintStream out = System.out;
    public static Scanner in = new Scanner(System.in);
    public static void main(String[] args) {
        int n = in.nextInt();
        int m = in.nextInt();
        int[][] a = new int[n][m];
        int c = 0;
        double sum = 0;

        //Ввод с консоли элементов массива размером NxM
        //Также вычисляем их количество и среднее арифметическое всех нечетных элементов массива
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                a[i][j] = in.nextInt();
                if (a[i][j] % 2 != 0) {
                    c += 1;
                    sum += a[i][j];
                }
            }
        }
        double ave = sum/c;

        //Сортировка каждого столбца массива по возрастанию методом пузырька
        int x;
        for (int k = 1; k < n; k++) {
            for (int i = n - 1; i > 0; i--) {
                for (int j = 0; j < m; j++) {
                    if (a[i][j] < a[i - 1][j]) {
                        x = a[i - 1][j];
                        a[i - 1][j] = a[i][j];
                        a[i][j] = x;
                    }
                }
            }
        }

        //Сортировка каждой строки массива по убыванию методом вставок
        for (int i = 0; i < n; i++) {
            for (int j = 1; j < m; j++) {
                int current = a[i][j];
                int k = j;
                while (k > 0 && a[i][k - 1] < current) {
                    a[i][k] = a[i][k - 1];
                    k--;
                }
                a[i][k] = current;
            }
        }

        //Сортировка главной диагонали по возрастанию
        int min = 1000000000;
        if (n < m)
            min = n;
        else min = m;
        for (int k = 1; k < min; k++) {
            for (int i = 0; i < min - 1; i++) {
                if (a[i][i] > a[i + 1][i + 1]) {
                    x = a[i + 1][i + 1];
                    a[i + 1][i + 1] = a[i][i];
                    a[i][i] = x;
                }
            }
        }
        //Вывод зигзагом
        int counter = 0;
        int n0 = 0, m0 = 0;
        while (n0 < n) {
            if (n0 % 2 == 0) {
                out.print(a[n0][m0] + " ");
                m0 += 1;
                counter += 1;
            }
            if (counter == m) {
                n0 += 1;
                counter = 0;
                m0 -= 1;
                //если здесь написать out.println() выведем как новый массив
            }
            if (n0 % 2 != 0 && n0 < n) {
                out.print(a[n0][m0] + " ");
                m0 -= 1;
                counter += 1;
            }
            if (counter == m) {
                n0 += 1;
                counter = 0;
                m0 += 1;
                //если здесь написать out.println() выведем как новый массив
            }
        }

        out.println();

        //Замена всех чётных чисел в массиве на их отрицательные значения, а нечётные - на их квадраты + вывод массива
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (a[i][j] % 2 == 0)
                    a[i][j] = -a[i][j];
                else a[i][j] = (int) Math.pow(a[i][j], 2);
                out.print(a[i][j] + " ");
            }
            out.println();
        }
    }
}
```

### 6. Анализ правильности решения

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на ограничение: N = 0, M = 5:

    - **Input**:
        ```
        0 5
        ```

    - **Output**:
        ```
        ```

2.  Тест на ограничение: N = -3, M = 4:

    - **Input**:
        ```
        -3 4
        ```

    - **Output**:
        ```
        Exception in thread "main" java.lang.NegativeArraySizeException: -3
        ```

3.  Тест на ограничение: N = -10000000000:

    - **Input**:
        ```
        -10000000000
        ```

    - **Output**:
        ```
        Exception in thread "main" java.util.InputMismatchException: For input string: "-1000000000000"
        ```

4.  Тест на ограничение: N = 2, M = 2, a[1][1] = 10000000000:

    - **Input**:
        ```
        2 2
        1 3 4 10000000000
        ```

    - **Output**:
        ```
        Exception in thread "main" java.util.InputMismatchException: For input string: "10000000000"

        ```

5. Тест: 

    - **Input**:
        ```
        3 3
        13 -2 2 11 -1 6 7 -9 9
        ```

    - **Output**:
        ```
        -1 2 -9 -2 6 11 13 9 7 
         1 -2 81 
         121 -6 2 
         169 81 49
        ```
        
6. Тест: 

    - **Input**:
        ```
        1 8
        11 -14 15 9 19 -8 -2 17
        ```

    - **Output**:
        ```
        19 17 15 11 9 -2 -8 -14 
        361 289 225 121 81 2 8 14
        ```
        
7. Тест: 

    - **Input**:
        ```
        5 3
        2 -10 19 18 11 -12 -17 20 -9 7 -5 16 6 15 1
        ```

    - **Output**:
        ```
        -10 -12 -17 -9 -5 2 11 6 1 7 15 16 20 19 18 
         10 12 289 
         -2 25 81 
         121 -6 1 
         -16 225 49 
         -20 361 -18 
        ```
        
8. Тест: 

    - **Input**:
        ```
        6 1
        3 -2 6 1 10 -7
        ```

    - **Output**:
        ```
        -7 -2 1 3 6 10 
         49 
         2 
         1 
         9 
         -6 
         -10 
        ```
